diff --git a/node_modules/discord.js/src/client/websocket/WebSocketShard.js b/node_modules/discord.js/src/client/websocket/WebSocketShard.js
index f99c83f..68b20c5 100644
--- a/node_modules/discord.js/src/client/websocket/WebSocketShard.js
+++ b/node_modules/discord.js/src/client/websocket/WebSocketShard.js
@@ -381,14 +381,14 @@ class WebSocketShard extends EventEmitter {
          * Emitted when the shard receives the READY payload and is now waiting for guilds
          * @event WebSocketShard#ready
          */
-        this.emit(ShardEvents.READY);
 
         this.sessionID = packet.d.session_id;
         this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));
         this.status = Status.WAITING_FOR_GUILDS;
-        this.debug(`[READY] Session ${this.sessionID}.`);
+        this.debug(`[READY] Session ${this.sessionID}`);
         this.lastHeartbeatAcked = true;
         this.sendHeartbeat('ReadyHeartbeat');
+        this.emit(ShardEvents.READY);
         break;
       case WSEvents.RESUMED: {
         /**
diff --git a/node_modules/discord.js/src/index.js b/node_modules/discord.js/src/index.js
index 32b98a0..d1bed14 100644
--- a/node_modules/discord.js/src/index.js
+++ b/node_modules/discord.js/src/index.js
@@ -20,6 +20,7 @@ module.exports = {
   BaseManager: require('./managers/BaseManager'),
   DiscordAPIError: require('./rest/DiscordAPIError'),
   HTTPError: require('./rest/HTTPError'),
+  DJSError: require('./errors/DJSError').Error,
   MessageFlags: require('./util/MessageFlags'),
   Intents: require('./util/Intents'),
   Permissions: require('./util/Permissions'),
@@ -104,4 +105,6 @@ module.exports = {
   Webhook: require('./structures/Webhook'),
 
   WebSocket: require('./WebSocket'),
+  WebSocketManager: require('./client/websocket/WebSocketManager'),
+  WebSocketShard: require('./client/websocket/WebSocketShard'),
 };
diff --git a/node_modules/discord.js/src/structures/Base.js b/node_modules/discord.js/src/structures/Base.js
index cd43bf7..e09d7d6 100644
--- a/node_modules/discord.js/src/structures/Base.js
+++ b/node_modules/discord.js/src/structures/Base.js
@@ -14,7 +14,7 @@ class Base {
      * @type {Client}
      * @readonly
      */
-    Object.defineProperty(this, 'client', { value: client });
+    Object.defineProperty(this, 'client', { value: client, writable: true }); // writable is needed, because Lambert overwrites some classes
   }
 
   _clone() {
diff --git a/node_modules/discord.js/typings/index.d.ts b/node_modules/discord.js/typings/index.d.ts
index 041039f..86a39ea 100644
--- a/node_modules/discord.js/typings/index.d.ts
+++ b/node_modules/discord.js/typings/index.d.ts
@@ -112,7 +112,7 @@ declare module 'discord.js' {
 
   export class Base {
     constructor(client: Client);
-    public readonly client: Client;
+    public client: Client; // must remove readonle, because Lambert overwrites some client objects
     public toJSON(...props: { [key: string]: boolean | string }[]): object;
     public valueOf(): string;
   }
@@ -122,7 +122,7 @@ declare module 'discord.js' {
     private _timeouts: Set<NodeJS.Timeout>;
     private _intervals: Set<NodeJS.Timeout>;
     private _immediates: Set<NodeJS.Immediate>;
-    private readonly api: object;
+    public readonly api: object;
     private rest: object;
     private decrementMaxListeners(): void;
     private incrementMaxListeners(): void;
@@ -422,6 +422,7 @@ declare module 'discord.js' {
       INVALID_SESSION: 'invalidSession';
       READY: 'ready';
       RESUMED: 'resumed';
+      ALL_READY: 'allReady';
     };
     PartialTypes: {
       [K in PartialTypes]: K;
@@ -592,6 +593,8 @@ declare module 'discord.js' {
     public httpStatus: number;
   }
 
+  export class DJSError extends Error {}
+
   export class DMChannel extends TextBasedChannel(Channel, ['bulkDelete']) {
     constructor(client: Client, data?: object);
     public messages: MessageManager;
@@ -617,9 +620,9 @@ declare module 'discord.js' {
 
   export class Guild extends Base {
     constructor(client: Client, data: object);
-    private _sortedRoles(): Collection<Snowflake, Role>;
-    private _sortedChannels(channel: Channel): Collection<Snowflake, GuildChannel>;
-    private _memberSpeakUpdate(user: Snowflake, speaking: boolean): void;
+    public _sortedRoles(): Collection<Snowflake, Role>;
+    public _sortedChannels(channel: Channel): Collection<Snowflake, GuildChannel>;
+    public _memberSpeakUpdate(user: Snowflake, speaking: boolean): void;
 
     public readonly afkChannel: VoiceChannel | null;
     public afkChannelID: Snowflake | null;
@@ -1781,12 +1784,12 @@ declare module 'discord.js' {
 
   export class WebSocketManager extends EventEmitter {
     constructor(client: Client);
-    private totalShards: number | string;
-    private shardQueue: Set<WebSocketShard>;
-    private packetQueue: object[];
-    private destroyed: boolean;
-    private reconnecting: boolean;
-    private sessionStartLimit: { total: number; remaining: number; reset_after: number } | null;
+    protected totalShards: number | string;
+    protected shardQueue: Set<WebSocketShard>;
+    protected packetQueue: object[];
+    protected destroyed: boolean;
+    protected reconnecting: boolean;
+    protected sessionStartLimit: { total: number; remaining: number; reset_after: number } | null;
 
     public readonly client: Client;
     public gateway: string | null;
@@ -1797,57 +1800,63 @@ declare module 'discord.js' {
     public on(event: WSEventType, listener: (data: any, shardID: number) => void): this;
     public once(event: WSEventType, listener: (data: any, shardID: number) => void): this;
 
-    private debug(message: string, shard?: WebSocketShard): void;
-    private connect(): Promise<void>;
-    private createShards(): Promise<void>;
-    private reconnect(): Promise<void>;
-    private broadcast(packet: object): void;
-    private destroy(): void;
-    private _handleSessionLimit(remaining?: number, resetAfter?: number): Promise<void>;
-    private handlePacket(packet?: object, shard?: WebSocketShard): boolean;
-    private checkShardsReady(): Promise<void>;
-    private triggerClientReady(): void;
+    protected debug(message: string, shard?: WebSocketShard): void;
+    protected connect(): Promise<void>;
+    protected createShards(): Promise<Boolean>;
+    protected reconnect(skipLimit? = false): Promise<void>;
+    protected broadcast(packet: object): void;
+    protected destroy(): void;
+    protected _handleSessionLimit(remaining?: number, resetAfter?: number): Promise<void>;
+    protected handlePacket(packet?: object, shard?: WebSocketShard): boolean;
+    protected checkShardsReady(): Promise<void>;
+    protected triggerClientReady(): void;
   }
 
   export class WebSocketShard extends EventEmitter {
     constructor(manager: WebSocketManager, id: number);
-    private sequence: number;
-    private closeSequence: number;
-    private sessionID: string | null;
-    private lastPingTimestamp: number;
-    private lastHeartbeatAcked: boolean;
-    private ratelimit: { queue: object[]; total: number; remaining: number; time: 60e3; timer: NodeJS.Timeout | null };
-    private connection: WebSocket | null;
-    private helloTimeout: NodeJS.Timeout | null;
-    private eventsAttached: boolean;
-    private expectedGuilds: Set<Snowflake> | null;
-    private readyTimeout: NodeJS.Timeout | null;
+    protected sequence: number;
+    protected closeSequence: number;
+    public sessionID: string | null;
+    protected lastPingTimestamp: number;
+    protected lastHeartbeatAcked: boolean;
+    protected ratelimit: {
+      queue: object[];
+      total: number;
+      remaining: number;
+      time: 60e3;
+      timer: NodeJS.Timeout | null;
+    };
+    protected connection: WebSocket | null;
+    protected helloTimeout: NodeJS.Timeout | null;
+    public eventsAttached: boolean;
+    protected expectedGuilds: Set<Snowflake> | null;
+    protected readyTimeout: NodeJS.Timeout | null;
 
     public manager: WebSocketManager;
     public id: number;
     public status: Status;
     public ping: number;
 
-    private debug(message: string): void;
-    private connect(): Promise<void>;
-    private onOpen(): void;
-    private onMessage(event: MessageEvent): void;
-    private onError(error: ErrorEvent | object): void;
-    private onClose(event: CloseEvent): void;
-    private onPacket(packet: object): void;
-    private checkReady(): void;
-    private setHelloTimeout(time?: number): void;
-    private setHeartbeatTimer(time: number): void;
-    private sendHeartbeat(): void;
-    private ackHeartbeat(): void;
-    private identify(): void;
-    private identifyNew(): void;
-    private identifyResume(): void;
-    private _send(data: object): void;
-    private processQueue(): void;
-    private destroy(destroyOptions?: { closeCode?: number; reset?: boolean; emit?: boolean; log?: boolean }): void;
-    private _cleanupConnection(): void;
-    private _emitDestroyed(): void;
+    protected debug(message: string): void;
+    public connect(): Promise<void>;
+    protected onOpen(): void;
+    protected onMessage(event: MessageEvent): void;
+    protected onError(error: ErrorEvent | object): void;
+    protected onClose(event: CloseEvent): void;
+    protected onPacket(packet: object): void;
+    protected checkReady(): void;
+    protected setHelloTimeout(time?: number): void;
+    protected setHeartbeatTimer(time: number): void;
+    protected sendHeartbeat(): void;
+    protected ackHeartbeat(): void;
+    protected identify(): void;
+    protected identifyNew(): void;
+    protected identifyResume(): void;
+    protected _send(data: object): void;
+    protected processQueue(): void;
+    public destroy(destroyOptions?: { closeCode?: number; reset?: boolean; emit?: boolean; log?: boolean }): void;
+    protected _cleanupConnection(): void;
+    protected _emitDestroyed(): void;
 
     public send(data: object): void;
     public on(event: 'ready' | 'resumed' | 'invalidSession', listener: () => void): this;
